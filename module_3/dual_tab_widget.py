# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'dual_tab_widget.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QSpinBox, QTableWidget,
    QTableWidgetItem, QComboBox
)
import glob
from PyQt5 import QtCore, QtGui, QtWidgets, QtMultimedia
from PyQt5.QtCore import QTimer
from module_3.layout_configuration_options_ver_2 import Ui_MainWindow  as uicmain
from module_3.upload_processing_uic import Process_Model 
from module_3.manage_signal_transmission_ver3 import Ui_MainWindow as AutomationInterface
from module_3.signal_processing_pyuic5 import DataProcessSignal 
import sys
import cv2,time,numpy as np
class CameraManager:
    def __init__(self,data):
        self._camera_data = data

    def register_camera(self, trigger_name, model_loader, ui):
        """Gán một camera vào hệ thống với trigger riêng."""
        self._camera_data[trigger_name] = {
            'model_loader': model_loader,
            'ui': ui
        }

    def get_camera_data(self, trigger_name):
        return self._camera_data.get(trigger_name, None)
    
    def engine_outdoor(self,image,model_loader,width_widget,height_widget):
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) 
        result_model = model_loader(image_rgb, size=640, conf=0.4)
        result = result_model.pandas().xyxy[0]
        result = result[result.name.isin(result_model.names)]
        result_image = np.squeeze(result_model.render())
        result_image_rgb = cv2.resize(result_image, (width_widget, height_widget), interpolation=cv2.INTER_AREA)
        flag = False
        return result_image_rgb,flag
    
    def handle_trigger_from_file(self, filepath, image_rgb):
        self.trigger_file_path = filepath
        self.image_rgb = image_rgb

    def read_plc(self,register_trigger,value_trigger):
        with open(self.trigger_file_path, 'r+') as file:
            line = file.readline().strip()
            if '=' not in line:
                return

            register, value = line.split('=')
            register = register.strip()
            value = int(value.strip())

            if register == register_trigger: 
                return value
            
            else: 
                return None

    def check_trigger_once(self):
        try:

            for key,values in self._camera_data:
                trigger = values['signals']['trigger']['read_register']
                trigger_read_value = values['signals']['trigger']['read_value']
                complete_write_register = values['signals']['complete']['write_register'] 

                if self.read_plc(trigger) == trigger_read_value:
                    model_loader = values['model_loader'][('camera-1', 'model-1')]
                    pyuic5 = values['pyuic'][('camera-1', 'model-1')]
                    path_instances = values['path_instances'][('camera-1', 'model-1')]
                    print('complete_write_register:',complete_write_register)


            # model = camera_data['model_loader']
            # t1 = time.time()
            # result_image_rgb, flag = self.engine_outdoor(self.image_rgb, model, 450, 450)
            # t2 = time.time()

            # cv2.putText(result_image_rgb, 'RESULT: OK' if flag else 'RESULT: NG',
            #             (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
            #             (0, 255, 0) if flag else (0, 0, 255), 1)
            # cv2.putText(result_image_rgb, f"Time: {t2 - t1:.2f}s", (10, 30),
            #             cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

            # cv2.imshow("Result", result_image_rgb)
            # cv2.waitKey(1)

        except Exception as e:
            print(f"[!] Trigger read error: {e}")
        
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
import queue
class Ui_MainWindow(object):

    def __init__(self,i_code,db,connect_db): 
        self.ui_child  = None
        self.i_code = i_code
        self.db = db
        self.connect_db = connect_db
        self.cursor = self.connect_db.connection.cursor()
        self.trigger_timer = QTimer()
        self.trigger_timer.setInterval(10)
        self.built_in_object = {}
        self.trigger_file_path = r"C:\gui_part\module_3\trigger.txt"
        self.executor = ThreadPoolExecutor(max_workers=4)
        self.counters = defaultdict(int)  # Mỗi camera có 1 counter riêng
        self.task = queue.Queue()
        self.task_timer = QtCore.QTimer()
        self.task_timer.setInterval(10)

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1879, 1004)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setMovable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.tab)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.tabWidget_2 = QtWidgets.QTabWidget(self.tab)
        self.tabWidget_2.setObjectName("tabWidget_2")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.tabWidget_2.addTab(self.tab_3, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.tabWidget_2.addTab(self.tab_4, "")
        self.horizontalLayout.addWidget(self.tabWidget_2)
        self.tabWidget.addTab(self.tab, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.tab_2)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.tabWidget_3 = QtWidgets.QTabWidget(self.tab_2)
        self.tabWidget_3.setObjectName("tabWidget_3")
        self.tab_5 = QtWidgets.QWidget()
        self.tab_5.setObjectName("tab_5")
        self.tabWidget_3.addTab(self.tab_5, "")
        self.tab_6 = QtWidgets.QWidget()
        self.tab_6.setObjectName("tab_6")
        self.tabWidget_3.addTab(self.tab_6, "")
        self.horizontalLayout_3.addWidget(self.tabWidget_3)
        self.tabWidget.addTab(self.tab_2, "")
        self.horizontalLayout_2.addWidget(self.tabWidget)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1879, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(1)
        self.tabWidget_2.setCurrentIndex(0)
        self.tabWidget_3.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        self.update_database()
        self.trigger_timer.timeout.connect(self.check_trigger_once)
        self.trigger_timer.start(10)
        self.task_timer.timeout.connect(self.task_ivy)
        self.task_timer.start(10)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.tabWidget_2.setTabText(self.tabWidget_2.indexOf(self.tab_3), _translate("MainWindow", "model 1"))
        self.tabWidget_2.setTabText(self.tabWidget_2.indexOf(self.tab_4), _translate("MainWindow", "model 2"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "camera 1 "))
        self.tabWidget_3.setTabText(self.tabWidget_3.indexOf(self.tab_5), _translate("MainWindow", "model 1"))
        self.tabWidget_3.setTabText(self.tabWidget_3.indexOf(self.tab_6), _translate("MainWindow", "model 2"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "camera 2"))

    def _select_database(self):
        self.cursor.execute("USE %s" % self.db)

    def _get_item_code_id(self, item_code):
        self.cursor.execute(
            "SELECT id FROM ITEMS_CODE WHERE name_line_code = %s",
            (item_code,)
        )
        result = self.cursor.fetchone()
        return result[0] if result else None

    def _get_camera_records(self, item_code_id):
        self.cursor.execute(
            "SELECT * FROM NUMS_CAMERA WHERE item_code_id = %s",
            (item_code_id,)
        )
        return self.cursor.fetchall()

    def _get_models_for_camera(self, camera_id):
        self.cursor.execute(
            "SELECT * FROM NUMS_MODEL WHERE camera_id = %s",
            (camera_id,)
        )
        return self.cursor.fetchall()

    def _create_camera_tab(self):
        tab = QtWidgets.QWidget()
        layout = QtWidgets.QHBoxLayout(tab)
        inner_tab = QtWidgets.QTabWidget()
        layout.addWidget(inner_tab)
        return tab

    def _set_dict(self,camera,ui_child,model_loader,path_instanses,_dict_signals,_shot_complete,_dict_shot,parameter_models):
        self.built_in_object[f'built-in-camera-{camera}']['pyuic'] = ui_child
        self.built_in_object[f'built-in-camera-{camera}']['model_loader'] = model_loader
        self.built_in_object[f'built-in-camera-{camera}']['path_instances'] = path_instanses
        self.built_in_object[f'built-in-camera-{camera}']['signals'] = _dict_signals
        self.built_in_object[f'built-in-camera-{camera}']['shot'] = _dict_shot
        self.built_in_object[f'built-in-camera-{camera}']['shot_complete'] = _shot_complete
        self.built_in_object[f'built-in-camera-{camera}']['parameter_models_x'] = parameter_models

   
    def _create_model_tabs(self,models,camera_name,camera_id):
        ui_instances,ui_modelloader,path_instanses,parameter_models= {},{},{},{}
        for model_index, _ in enumerate(models):
            model_number = model_index + 1
            new_tab = QtWidgets.QMainWindow()
            self.ui_child = uicmain()
            self.ui_child.setupUi(new_tab)
            self.processor = Process_Model(self.ui_child)
            self.processor.assign_values(model_number, camera_name, self.i_code)
            self.processor.load_parameter_injection_safe(camera_id, model_number,self.cursor,self.connect_db,self.tabWidget,ui_instances)
            ui_instances[(f'camera-{camera_name}', f'model-{model_number}')] = self.ui_child
            ui_modelloader[(f'camera-{camera_name}',f'model-{model_number}')] = self.processor.model_loader
            path_instanses[(f'camera-{camera_name}',f'model-{model_number}')] = self.processor.path_object
            parameter_models[(f'camera-{camera_name}',f'model-{model_number}')] = self.processor.parametes_model
            self.ui_child.pushButton.clicked.connect(lambda _,unit=self.processor:unit.browse_file())
            self.ui_child.pushButton_2.clicked.connect(lambda _,unit=self.processor:unit.load_model())
            self.ui_child.pushButton_6.clicked.connect(lambda _,unit=self.processor:unit.save_values_injection_safe(self.cursor, self.connect_db))
            self.ui_child.pushButton_21.clicked.connect(lambda _,unit=self.processor:unit.browse_file_detect())
            self.ui_child.pushButton_22.clicked.connect(lambda _,unit=self.processor:unit.detect_img())
            self.ui_child.pushButton_7.clicked.connect(lambda _,unit=self.ui_child:unit.toggle_lock())
            self.ui_child.pushButton_5.clicked.connect(lambda _,unit=self.processor:unit.load_data_injection_safe())
            self.tabWidget_2.addTab(new_tab, f"Model {model_number}")
            self.product_code_forms.append(new_tab)

        return ui_instances,ui_modelloader,path_instanses,parameter_models
        
    def update_database(self):
        self.tabWidget_2.clear()
        self.tabWidget.clear()
        self.product_code_forms = []
        self._select_database()
        item_code_id = self._get_item_code_id(self.i_code)
        if not item_code_id:
            return
        camera_records = self._get_camera_records(item_code_id)
        for index, record in enumerate(camera_records):
            camera_id, camera_name = record[0], record[1]
            tab = self._create_camera_tab()
            self.tabWidget.addTab(tab, f"Camera {camera_name}")
            self.tabWidget_2 = tab.findChild(QtWidgets.QTabWidget)
            models = self._get_models_for_camera(camera_id)
            if camera_name not in self.built_in_object:
                self.built_in_object[f'built-in-camera-{camera_name}'] = {}
            ui_instances,ui_modelloader,path_instanses,parameter_models = self._create_model_tabs(models,camera_name,camera_id)
            AutomationInterface_t = QtWidgets.QMainWindow()
            self.Automation = AutomationInterface()
            _translate = QtCore.QCoreApplication.translate
            self.Automation.setupUi(AutomationInterface_t)
            self.tabWidget_2.addTab(AutomationInterface_t, f"Automation")
            self.DataProcessSignal = DataProcessSignal(self.Automation)
            self.Automation.comboBox_camera.setItemText(0, _translate("MainWindow", str(camera_name)))
            self.Automation.comboBox_n_model.setItemText(0, _translate("MainWindow", str(len(models))))
            self.Automation.comboBox_Itemcode.setItemText(0, _translate("MainWindow", str(self.i_code)))
            self.Automation.spinBox.valueChanged.connect(lambda _,unit=self.Automation:unit.generate_table())
            mode_auto_id = self.DataProcessSignal.load_values_signals_from_db(self.cursor,camera_id)
            self.DataProcessSignal.load_shotxmodel_from_db(self.cursor,mode_auto_id)
            _shot_complete,_dict_shot = self.DataProcessSignal.dict_shotxmodel()
            self.Automation.pushButton_apply_signal.clicked.connect(lambda _,unit=self.DataProcessSignal:unit.save_values_signal_to_db(self.cursor,self.connect_db,item_code_id))
            self.product_code_forms.append(AutomationInterface_t)
            _dict_signals = self.DataProcessSignal.get_table_params()
            self._set_dict(camera_name,ui_instances,ui_modelloader,path_instanses,_dict_signals,_shot_complete,_dict_shot,parameter_models)
            self.Automation.pushButton_modify.clicked.connect(lambda _,unit=self.DataProcessSignal:unit.save_shotxmodel_to_db(self.cursor,self.connect_db,item_code_id))

    def read_plc(self,register_trigger):
        try:
            with open(self.trigger_file_path, 'r') as file:
                line = file.readline().strip()
                if '=' not in line:
                    return 0
                register, value = line.split('=')
                register = register.strip()
                value = int(value.strip())
                if register == register_trigger: 
                    return value
                else: 
                    return 0
        except (IOError, PermissionError):
            try:
                with open(self.trigger_file_path, 'w') as file:
                    file.write('trigger=0\n')
                return 0
            except:
                print(f"Cannot access trigger file: {self.trigger_file_path}")
                return 0
            
    def write_plc(self, register, value):
        try:
            with open(self.trigger_file_path, 'w') as file:
                line = f"{register} = {value}\n"
                file.write(line)
        except (IOError, PermissionError) as e:
            print(f"Error writing to trigger file: {e}")
            return False
        return True
    
    def check_trigger_once(self):
        if not self.built_in_object:
            return

        for key, values in self.built_in_object.items():
            signals = values['signals']['trigger']
            trigger = signals['read_register']
            trigger_read_value = signals['read_value']

            try:
                if int(self.read_plc(trigger)) == int(trigger_read_value):
                    self.write_plc(trigger, 0)  
                    self.task.put((key, values))
            except Exception as e:
                print(f"[{key}] Error while reading trigger: {e}")

    def task_ivy(self):
        if not self.task.empty():
            try:
                key, values = self.task.get_nowait()
                self.executor.submit(self.handle_triggered_camera, key, values)
            except queue.Empty:
                pass

    def handle_triggered_camera(self, key, values):
        self.counters[key] += 1
        current_count = self.counters[key]
        print(f"[{key}] Counter = {current_count}")

        t1 = time.time()
        num_model = values['shot'].get(str(current_count))
        if not num_model:
            print(f"[{key}] No model found for counter {current_count}")
            return

        model_loader_dict = values['model_loader']
        pyuic_dict = values['pyuic']
        path_instances_dict = values['path_instances']
        parameter_model = values['parameter_models_x']

        for (shot, model_full), pyuic5 in pyuic_dict.items():
            model_base = model_full.split('-')[0]
            key_model = (shot, f'{model_base}-{num_model}')

            model_loader = model_loader_dict.get(key_model)
            path_folder = str(path_instances_dict.get(key_model, ''))
            pyuic5 = pyuic_dict.get(key_model)
            list_params = parameter_model.get(key_model)
           
            image_list = glob.glob(f"{path_folder}/*.jpg")
            if not image_list:
                print(f"[{key}] No image found at {path_folder}")
                continue

            image_path = image_list[0]
            image_rgb = cv2.imread(image_path)
            if image_rgb is None:
                print(f"[{key}] Failed to read image: {image_path}")
                continue

            result_image_rgb, flag = self.engine_outdoor(image_rgb, model_loader, 450, 450)

            elapsed = time.time() - t1
            result_text = f'RESULT: {"OK" if flag else "NG"} {elapsed:.2f}'
            color = (0, 255, 0) if flag else (0, 0, 255)

            cv2.putText(result_image_rgb, result_text, (10, 50),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)

            h, w = result_image_rgb.shape[:2]
            qimage = QtGui.QImage(result_image_rgb.data, w, h, result_image_rgb.strides[0], QtGui.QImage.Format_RGB888)
            pixmap = QtGui.QPixmap.fromImage(qimage)
            QtCore.QMetaObject.invokeMethod(pyuic5.label_5, "setPixmap", QtCore.Qt.QueuedConnection,
                                            QtCore.Q_ARG(QtGui.QPixmap, pixmap))
            os.remove(image_path)

        if current_count == values.get('shot_complete', 0):
            self.counters[key] = 0

    def check_trigger_sencond(self):
        if self.built_in_object:
            for key, values in self.built_in_object.items():
                signals = values['signals']['trigger']
                trigger = signals['read_register']
                trigger_read_value = signals['read_value']

                if int(self.read_plc(trigger)) == int(trigger_read_value):
                    self.counter += 1
                    print('self.counter:', self.counter)

                    t1 = time.time()
                    self.write_plc(trigger, 0)

                    num_model = values['shot'].get(str(self.counter))
                    if not num_model:
                        continue

                    model_loader_dict = values['model_loader']
                    pyuic_dict = values['pyuic']
                    path_instances_dict = values['path_instances']

                    for (shot, model_full), pyuic5 in pyuic_dict.items():
                        model_base = model_full.split('-')[0]
                        key_model = (shot, f'{model_base}-{num_model}')
                        model_loader = model_loader_dict.get(key_model)
                        path_folder = str(path_instances_dict.get(key_model, ''))
                        pyuic5 = pyuic_dict.get(key_model)
                        image_list = glob.glob(f"{path_folder}/*.jpg")
                        
                        if image_list:
                            image_path = image_list[0]
                            image_rgb = cv2.imread(image_path)
                            result_image_rgb, flag = self.engine_outdoor(image_rgb, model_loader, 450, 450)
                            
                            elapsed = time.time() - t1
                            text = f'RESULT: {"OK" if flag else "NG"} {elapsed:.2f}'
                            color = (0, 255, 0) if flag else (0, 0, 255)

                            cv2.putText(result_image_rgb, text, (10, 50),
                                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)

                            h, w = result_image_rgb.shape[:2]
                            qimage = QtGui.QImage(result_image_rgb.data, w, h, result_image_rgb.strides[0],
                                                QtGui.QImage.Format_RGB888)
                            pixmap = QtGui.QPixmap.fromImage(qimage)
                            pyuic5.label_5.setPixmap(pixmap)

                            os.remove(image_path)
                        else:
                            print("No images found in the specified path.")

                    if self.counter == values['shot_complete']:
                        self.counter = 0

    def check_trigger_third(self):
        if True:
            if self.built_in_object != {}:
                for key,values in self.built_in_object.items():
                    trigger = values['signals']['trigger']['read_register']
                    trigger_read_value = values['signals']['trigger']['read_value']  
                    if int(self.read_plc(trigger)) == int(trigger_read_value):
                        self.counter += 1 
                        print('self.counter: ', self.counter )
                        t1 = time.time()
                        self.write_plc(trigger,0)
                        num_model = values['shot'][str(self.counter)]
                        for k,v in values['pyuic'].items():
                            shot = k[0]
                            model = k[1].split('-')[0]
                            total = (shot,f'{model}-{num_model}')
                            model_loader = values['model_loader'][total]
                            pyuic5 = values['pyuic'][total]
                            path_instances = values['path_instances'][total]
                            path_image  = str(path_instances)+'/*.jpg'
                            image_list = glob.glob(path_image)
                            if image_list:
                                image_path = image_list[0]
                                image_rgb = cv2.imread(image_path)
                                result_image_rgb, flag = self.engine_outdoor(image_rgb, model_loader, 450, 450)
                                t2 = time.time()-t1
                                cv2.putText(result_image_rgb, f'RESULT: OK {t2:.2f}' if flag else f'RESULT: NG {t2:.2f}',
                                            (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                                            (0, 255, 0) if flag else (0, 0, 255), 1)
                                
                                qimage = QtGui.QImage(result_image_rgb.data, result_image_rgb.shape[1], result_image_rgb.shape[0], result_image_rgb.strides[0], QtGui.QImage.Format_RGB888)
                                pixmap = QtGui.QPixmap.fromImage(qimage)
                                pyuic5.label_5.setPixmap(pixmap)

                                os.remove(image_path)
                            else:
                                print("No images found in the specified path.")

                        if values['shot_complete'] == self.counter:
                            self.counter = 0

    def engine_outdoor(self,image,model_loader,width_widget,height_widget):
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB) 
        result_model = model_loader(image_rgb, size=768)
        result = result_model.pandas().xyxy[0]
        result = result[result.name.isin(result_model.names)]
        result_image = np.squeeze(result_model.render())
        result_image_rgb = cv2.resize(result_image, (width_widget, height_widget), interpolation=cv2.INTER_AREA)
        flag = False
        return result_image_rgb,flag
    
    
from PyQt5 import QtWidgets, QtCore
import os

class intermediate_layer:
    def __init__(self, i_code, db, connect_db):
        self.i_code = i_code
        self.db = db
        self.connect_db = connect_db
        self.MainWindow = QtWidgets.QMainWindow()
        ui = Ui_MainWindow(self.i_code, self.db, self.connect_db)
        ui.setupUi(self.MainWindow)
        self.show_window()

    def show_window(self):
        self.MainWindow.showMaximized()
        self.MainWindow.raise_()
        self.MainWindow.activateWindow()